{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"浵通","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"java reflection","slug":"java反射机制","date":"2018-08-04T07:33:41.683Z","updated":"2018-08-04T10:47:54.026Z","comments":true,"path":"2018/08/04/java反射机制/","link":"","permalink":"http://yoursite.com/2018/08/04/java反射机制/","excerpt":"","text":"##什么是java反射机制？反射这个概念用在生物学中是指在中枢神经系统的参与下，人的机体对外界环境刺激作出的规律性的反应。那么反射在java中赋予了新的含义，即程序在运行时可以动态加载编译期完全未知的类，并动态获取整个类的完整结构，从而达到运行时去动态检测类的状态并修改类的结构的目的。 从具体实现的角度来说：通过Class类，在程序运行中，可以动态获取编译期未知的类的成员变量，动态的调用类中任意的方法，获取当前对象所属的类，这种动态获取类自身的信息并进行动态改变类结构的功能就被称为java的反射机制。 ##java反射机制提供了哪些功能？与java发射相关的API在包java.lang.raflect中。 java.lang.reflect API中最核心的类是Class 类（也可以称之为反射类，java就是通过这个反射类实现了java的反射的功能）。获取Class类的对象有三种方式： .class 每个类都隐含一个Class对象Class class=String.class 通过getClass方法String str=”java reflect”Class class=str.getClass(); 通过Class.forName(“”);Class class=Calss.forName(“java.lang.String”); Class类的方法如下： getName():获取类的完整名字 getFileds():获取类的公有属性 getDeclaredFileds():获取类的所有属性 getMethods():获取类的公有方法 getDeclaredMethods():获取类的所有方法 getMethod(String name,Class[] parameterTypes)获取指定类的指定参数列表的方法 getConstructors():获取类的公有的构造方法 getConstructor(Class[] parameterTypes):获取类特定的构造方法 newInstance():通过类的不带参数的构造方法创建这个类的一个对象； 除了上述的Class类，与反射相关的类还有如下列举的： Array类 提供动态生成和访问java数组的方法 Constructor类 提供一个类的构造函数的信息，同时提供访问一个类的构造函数的接口 Filed类 提供一个类的成员变量的信息以及访问类成员变量的接口 Method类 提供一个类的方法的信息以及访问类中的方法的接口 Modifiler类 提供一个类static方法和常量的信息 Proxy 提供动态生成代理类和类实例的静态方法 综上Reflect提供的API，总结出java反射机制提供的功能： 在运行时判断对象所属的类型 在运行时获取类的完整信息，包括成员变量和方法，常量和静态方法 在运行时动态创建对象 在运行时调用类中任意的方法 创建动态代理实例","categories":[],"tags":[]},{"title":"蘑菇街平台技术部实习收获与感悟","slug":"实习总结","date":"2018-08-04T06:32:46.662Z","updated":"2018-08-04T10:41:34.004Z","comments":true,"path":"2018/08/04/实习总结/","link":"","permalink":"http://yoursite.com/2018/08/04/实习总结/","excerpt":"","text":"知识方面：基于之前对消息中间件一些浅显的认知基础上，通过这次实习，对rocketmq和kafka的分布式消息存储机制有了更深的理解，同时也对二者的存储实现机制做了对比和性能分析。但是由于时间比较短暂，也没有机会真正的实践，后面希望自己能有机会从源码的角度去更全面的理解消息中间件产品，并能做一些思考和实践，真正去体会消息中间件产生的意义和应用的场景。 性能优化方面： 在实现一键邮件通知客户端升级的功能的过程中，有批量访问米兰服务和批量发送邮件的需求。如果仅仅是用串行来做，那么QPS和RTT都达不到预期值。二者都可以看作是远程调用，那么首先定位影响系统性能的因素在网络IO。那么解决网络IO慢的方式通常有两种：多线程和网络异步，因为console本身对性能的要求并没有那么高，而且使用console的频率也并不高，因此采用了多线程的方式来实现。那么多线程对性能的提高取决于任务的类型，即任务可以被并行执行的部分占整个任务的比重，在这里多次请求之间是完全可以并行的，还有就是线程数的设置。基于我以前的认知，我认为线程数的设置和任务的性质有关，任务是IO密集型还是CPU密集型，线程数的设置是不一样的。对于IO密集型，因为存在阻塞，那么线程数可以设置的大于处理器的逻辑核数，反之应该和逻辑核数相等。而线程数的上限应该和内存有关，因为每个线程都需要有自己的栈空间。基于上述的认识，我将核数设置成和核数相等的数，发现RTT没有丝毫变换。我想了一下原因，上述设置线程数的规则并没有错，但是是有条件的，我想只有当每个子任务没有阻塞并且负载都及其高的情况下，设置线程数和核数相等就不会有问题。所以提高了线程数到100 ，发现RTT降低了，在继续增加线程数发现RTT没有降 低反而提高了。 理论上，多线程的RTT取决于子任务最慢的那一个的RTT，那么随着线程数的增多应该不会提高。开始分析的时候，我觉得是因为线程数增多，必然会导致cs的时间增大，会不会影响RTT呢？确认CS的时间会远远小于网络传输的时间，因此做了单次RPC RTT的测试，分析出RTT无法在降低主要是因为米兰系统没有提供高并发的场景，扛不住这么高的QPS。 通过这次实习的经历，我对性能优化的问题也不再感到慌乱。衡量一个系统性能一般有两个指标 。 QPS，RTT。影响系统性能的因素大多发生在多次访存，或者磁盘，或者网络IO。对于内存，可以根据cache的特性，优化代码，提高cache命中率，减少访存次数，对于磁盘，可以增加缓存，同时尽量保证是顺序访问磁盘，对于网络IO可以通过网络异步方式提高RTT和QPS。对于网络IO瓶颈，RTT取决于调用方的RTT和远程服务处理的RTT，以及网络传输的延迟。网络传输是不可控的，那么只能从调用方做优化，但优化的同时需要考虑我们对远程服务QPS的要求，否则可能会因为对方无法承受高QPS而导致服务挂掉。 代码重构：这次代码重构可能花费将近2个星期左右的时间。我在这方面也比较欠缺，之前编码目标就是实现功能，很少考虑到代码的可重用性和可维护性。这次经历我也明白了编码的时候不仅仅要考虑功能，代码的设计同样重要。体会比较深的是对功能的高度的抽象，达到最后每一个模块都可以重用，第二就是异常的处理，第三就是编码的时候逻辑思维一定要缜密，边边角角都要考虑到。 实习的这段时间，感觉自己相比之前，从宏观上懂了很多套路，希望自己在今后的学习生，可以仔细去领悟和琢磨，能细化一些并不是理解很深的点。最后感觉学长对我毫不保留的指导，也感谢组里其他同事对我的照顾和指导。最后祝大家工作顺利，也祝公司越来越好！","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-08-04T05:52:14.928Z","updated":"2018-08-04T05:52:14.928Z","comments":true,"path":"2018/08/04/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}