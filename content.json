{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"浵通","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"java反射机制-动态代理","slug":"java反射机制 - 动态代理","date":"2018-08-04T16:19:34.755Z","updated":"2018-08-05T03:38:37.283Z","comments":true,"path":"2018/08/05/java反射机制 - 动态代理/","link":"","permalink":"http://yoursite.com/2018/08/05/java反射机制 - 动态代理/","excerpt":"","text":"java的设计模式-代理模式代理模式中存在两种对象：代理类 和委托类 代理模式的特点：代理类和委托类都实现相同的接口，委托类委托代理类实现一些与核心业务无关的通用业务逻辑，而自己专注处理核心的业务逻辑。例如演艺圈，艺人们都需要经纪人去代替他们和第三方洽谈档期等等事宜，而他们则专注做好表演的工作。那么经纪人就起着代理的作用。代理模式结构如图（图片来自大话设计模式）： 静态代理模式静态代理模式中的代理类是由程序员创建或者工具创建，在程序编译期间，接口、代理类和被代理类就是确定的。类比明星，静态代理模式下每位艺人都会安排固定的经纪人，不管艺人的档期的忙或闲，某个经纪人就只负责代理特定的艺人的事务。下面通过一个简单的静态代理的例子来描述静态代理 共有的接口 interface Person&#123;123 public void sing(String name);&#125; 委托类： 123456public class Star implements Person&#123; public void sing(String name) &#123; System.out.println(&quot;正在演唱：&quot;+name); &#125;&#125; 代理类： 1234567891011121314public class Proxy implements Person&#123; Star star; public Proxy(Person person) &#123; if(person.getClass()==Star.class) &#123; this.star=person; &#125; &#125; public void sing(String name) &#123; System.out.println(&quot;通知明星演唱&quot;); star.sing(name); &#125;&#125; 测试 12345678910public class StaticProxyTest&#123; public static void main(String[] args) &#123; //创建被委托对象 Star star=new Star(); //创建代理对象 Proxy proxy=new Proxy(star); proxy.sing(&quot;同一首歌&quot;); &#125;&#125; 动态代理从上述的静态代理的例子中可以得到结论：静态代理模式中的代理类在运行前必须编写好，如果需要为多个艺人代理，那就必须预先编写好所有的为每位艺人代理的代理类。这样做，成本非常高，试想一下，如果很多艺人都是三线或者四线，档期很空闲，那么他们的艺人就会无事可做，导致资源浪费。为什么不是根据当前艺人们的需求动态配置经纪人呢？因此动态代理就产生了。 动态代理模式中的代理类是在程序运行期间动态生成的。类比艺人，当某个艺人需要代理事务时，从现有的代理中查询有没有合适的经纪人可以代理此艺人的当前的事务，如果没有就为该艺人配置一个新的艺人。下面举例说明： 程序运行时动态生成代理对象 12345678910111213141516171819202122232425262728public class Proxy &#123; //即将被代理的对象 Person person; public Proxy(Person person)&#123; this.person=person; &#125; //已经被代理的对象(将被代理对象和代理对象关联) public Person getPersonProxy() &#123; ClassLoader loader=Person.class.getClassLoader(); Class[] interfaces= &#123;Person.class&#125;; InvocationHandler h=new InvocationHandler() &#123; //proxy 代理的对象 //method 被代理的对象中的方法 //参数 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;通知明星演唱：&quot;); Object o=method.invoke(person, args); return o; &#125; &#125;; Person p=(Person)Proxy.newProxyInstance(loader, interfaces, h); return p; &#125;&#125; 测试 12345678public class DynamicProxy&#123; public static void mian(String[] args) &#123; //获取代理类对象 Person p=(Person)new Proxy(new Star()).getPersonProxy(); p.sing(&quot;同一首歌&quot;); &#125;&#125; 通过上述动态代理的例子发现动态代理中的代理类是在程序运行时生成。动态代理抽象了InvocationHandler接口，对代理类代理的事务方法进行统一处理（这里用到java反射，Method.invoke（）方法执行方法调用）。我们可以很方便的在方法执行前后增加核心业务无关的业务逻辑，例如日志，验证等等，大大的减少了代码量。 简单分析newProxyInstance的过程123456789生成与指定的类加载器和一组接口相关的代理类Class cl = getProxyClass(loader, interfaces); 保存已经生成的代理类，在生成代理类时，如果存在与指定类加载器和一组接口相关的代理类，则直接返回，否则生成新的代理类。 proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());通过反射获取构造函数并生成代理类实例对象final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);cons.newInstance(new Object[]&#123;h&#125;);","categories":[],"tags":[]},{"title":"java反射机制的基本概念","slug":"java反射机制","date":"2018-08-04T07:33:41.683Z","updated":"2018-08-04T15:45:57.098Z","comments":true,"path":"2018/08/04/java反射机制/","link":"","permalink":"http://yoursite.com/2018/08/04/java反射机制/","excerpt":"","text":"什么是java反射机制？反射这个概念用在生物学中是指在中枢神经系统的参与下，人的机体对外界环境刺激作出的规律性的反应。那么反射在java中赋予了新的含义，即程序在运行时可以动态加载编译期完全未知的类，并动态获取整个类的完整结构，从而达到运行时去动态检测类的状态并修改类的结构的目的。 从具体实现的角度来说：通过Class类，在程序运行中，可以动态获取编译期未知的类的成员变量，动态的调用类中任意的方法，获取当前对象所属的类，这种动态获取类自身的信息并进行动态改变类结构的功能就被称为java的反射机制。 java反射机制提供了哪些功能？与java发射相关的API在包java.lang.raflect中。 java.lang.reflect API中最核心的类是Class 类（也可以称之为反射类，java就是通过这个反射类实现了java的反射的功能）。获取Class类的对象有三种方式： .class 每个类都隐含一个Class对象Class class=String.class 通过getClass方法String str=”java reflect”Class class=str.getClass(); 通过Class.forName(“”);Class class=Calss.forName(“java.lang.String”); Class类的方法如下： getName():获取类的完整名字 getFileds():获取类的公有属性 getDeclaredFileds():获取类的所有属性 getMethods():获取类的公有方法 getDeclaredMethods():获取类的所有方法 getMethod(String name,Class[] parameterTypes)获取指定类的指定参数列表的方法 getConstructors():获取类的公有的构造方法 getConstructor(Class[] parameterTypes):获取类特定的构造方法 newInstance():通过类的不带参数的构造方法创建这个类的一个对象； 除了上述的Class类，与反射相关的类还有如下列举的： Array类 提供动态生成和访问java数组的方法 Constructor类 提供一个类的构造函数的信息，同时提供访问一个类的构造函数的接口 Filed类 提供一个类的成员变量的信息以及访问类成员变量的接口 Method类 提供一个类的方法的信息以及访问类中的方法的接口Method.invoke() Modifiler类 提供一个类static方法和常量的信息 Proxy 提供动态生成代理类和类实例的静态方法 综上Reflect提供的API，总结出java反射机制提供的功能： 在运行时判断对象所属的类型 object.getClass==Onject.class 在运行时获取类的完整信息，包括成员变量和方法，常量和静态方法 在运行时动态创建对象 class.newInstance() 在运行时调用类中任意的方法Method[] methods=getDeclaredMethods()&amp;&amp;method.invoke(Object,parameters[]) 创建动态代理实例 Proxy.newProxyInstance(classloader, interfaces, InvocationHandler) java反射机制的弊端？ java反射机制核心思想是在程序运行时动态加载编译期完全未知的类，那么必然会损失程序的性能，对于性能要求高的程序尽量慎重使用java反射 java反射机制将整个类的结构完全暴漏给了用户，破坏了类的封装性，有可能会造成安全威胁，对于安全性要求高的系统要尽量避免java反射","categories":[],"tags":[]},{"title":"蘑菇街平台技术部实习收获与感悟","slug":"实习总结","date":"2018-08-04T06:32:46.662Z","updated":"2018-08-04T10:41:34.004Z","comments":true,"path":"2018/08/04/实习总结/","link":"","permalink":"http://yoursite.com/2018/08/04/实习总结/","excerpt":"","text":"知识方面：基于之前对消息中间件一些浅显的认知基础上，通过这次实习，对rocketmq和kafka的分布式消息存储机制有了更深的理解，同时也对二者的存储实现机制做了对比和性能分析。但是由于时间比较短暂，也没有机会真正的实践，后面希望自己能有机会从源码的角度去更全面的理解消息中间件产品，并能做一些思考和实践，真正去体会消息中间件产生的意义和应用的场景。 性能优化方面： 在实现一键邮件通知客户端升级的功能的过程中，有批量访问米兰服务和批量发送邮件的需求。如果仅仅是用串行来做，那么QPS和RTT都达不到预期值。二者都可以看作是远程调用，那么首先定位影响系统性能的因素在网络IO。那么解决网络IO慢的方式通常有两种：多线程和网络异步，因为console本身对性能的要求并没有那么高，而且使用console的频率也并不高，因此采用了多线程的方式来实现。那么多线程对性能的提高取决于任务的类型，即任务可以被并行执行的部分占整个任务的比重，在这里多次请求之间是完全可以并行的，还有就是线程数的设置。基于我以前的认知，我认为线程数的设置和任务的性质有关，任务是IO密集型还是CPU密集型，线程数的设置是不一样的。对于IO密集型，因为存在阻塞，那么线程数可以设置的大于处理器的逻辑核数，反之应该和逻辑核数相等。而线程数的上限应该和内存有关，因为每个线程都需要有自己的栈空间。基于上述的认识，我将核数设置成和核数相等的数，发现RTT没有丝毫变换。我想了一下原因，上述设置线程数的规则并没有错，但是是有条件的，我想只有当每个子任务没有阻塞并且负载都及其高的情况下，设置线程数和核数相等就不会有问题。所以提高了线程数到100 ，发现RTT降低了，在继续增加线程数发现RTT没有降 低反而提高了。 理论上，多线程的RTT取决于子任务最慢的那一个的RTT，那么随着线程数的增多应该不会提高。开始分析的时候，我觉得是因为线程数增多，必然会导致cs的时间增大，会不会影响RTT呢？确认CS的时间会远远小于网络传输的时间，因此做了单次RPC RTT的测试，分析出RTT无法在降低主要是因为米兰系统没有提供高并发的场景，扛不住这么高的QPS。 通过这次实习的经历，我对性能优化的问题也不再感到慌乱。衡量一个系统性能一般有两个指标 。 QPS，RTT。影响系统性能的因素大多发生在多次访存，或者磁盘，或者网络IO。对于内存，可以根据cache的特性，优化代码，提高cache命中率，减少访存次数，对于磁盘，可以增加缓存，同时尽量保证是顺序访问磁盘，对于网络IO可以通过网络异步方式提高RTT和QPS。对于网络IO瓶颈，RTT取决于调用方的RTT和远程服务处理的RTT，以及网络传输的延迟。网络传输是不可控的，那么只能从调用方做优化，但优化的同时需要考虑我们对远程服务QPS的要求，否则可能会因为对方无法承受高QPS而导致服务挂掉。 代码重构：这次代码重构可能花费将近2个星期左右的时间。我在这方面也比较欠缺，之前编码目标就是实现功能，很少考虑到代码的可重用性和可维护性。这次经历我也明白了编码的时候不仅仅要考虑功能，代码的设计同样重要。体会比较深的是对功能的高度的抽象，达到最后每一个模块都可以重用，第二就是异常的处理，第三就是编码的时候逻辑思维一定要缜密，边边角角都要考虑到。 实习的这段时间，感觉自己相比之前，从宏观上懂了很多套路，希望自己在今后的学习生，可以仔细去领悟和琢磨，能细化一些并不是理解很深的点。最后感觉学长对我毫不保留的指导，也感谢组里其他同事对我的照顾和指导。最后祝大家工作顺利，也祝公司越来越好！","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-08-04T05:52:14.928Z","updated":"2018-08-04T05:52:14.928Z","comments":true,"path":"2018/08/04/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}